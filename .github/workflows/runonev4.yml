name: Launch GUI Script V2 (bulletproof)

on:
  workflow_dispatch:
    inputs:
      wait_for_login:
        description: "Verificar/esperar sesión interactiva de 'mariano' (autologon)"
        type: boolean
        default: true
      force_display:
        description: "Forzar resolución con NirCmd antes de ejecutar"
        type: boolean
        default: true
      tail_log:
        description: "Mostrar tail del log al final"
        type: boolean
        default: true

env:
  SCRIPT_TO_RUN: "C:\\Users\\mariano\\Documents\\DMV Automation - 10 Jun V2\\One_new-Copy2 (2).py"
  RUN_AS_USER: "mariano"          # nombre corto, sin .\
  NIRCMD_EXE: "C:\\nircmd.exe"
  RES_W: "1920"
  RES_H: "1080"
  RES_BPP: "32"
  TASK_NAME_BASE: "LanzarAppGUI"
  LOG_DIR: "C:\\Scripts\\logs"
  TASK_WRAPPER_DIR: "C:\\Scripts\\tasks"   # acá guardamos el .cmd wrapper

jobs:
  launch:
    runs-on: [self-hosted, windows, gui]
    defaults:
      run:
        shell: powershell

    steps:
      - name: (Opcional) Verificar/esperar sesión interactiva de $env:RUN_AS_USER
        if: ${{ inputs.wait_for_login }}
        run: |
          $u = "${env:RUN_AS_USER}"
          $deadline = (Get-Date).AddMinutes(5)
          do {
            $q = (quser | Out-String)
            if ($q -match "(?im)^[\s>]*$([regex]::Escape($u))\b.*\sActive\b") { Write-Host "OK: sesión de $u activa"; exit 0 }
            Start-Sleep 2
          } while ((Get-Date) -lt $deadline)
          Write-Host "=== quser ===`n$q"
          throw "No hay sesión interactiva de '$u'. Corré primero el workflow 1 para que el autologon la cree."

      - name: Crear y ejecutar tarea en la sesión de $env:RUN_AS_USER (schtasks /IT con wrapper)
        run: |
          $ErrorActionPreference = 'Stop'

          $tn  = $env:TASK_NAME
          $u   = $env:RUN_AS_USER
          $cmd = $env:CMD_FILE

          # 1) Borrar si existe (best-effort, SIN romper el step)
          $p = Start-Process -FilePath schtasks -ArgumentList @('/Query','/TN',"$tn") -NoNewWindow -Wait -PassThru -ErrorAction SilentlyContinue
          if ($p -and $p.ExitCode -eq 0) {
            $pDel = Start-Process -FilePath schtasks -ArgumentList @('/Delete','/TN',"$tn",'/F') -NoNewWindow -Wait -PassThru -ErrorAction SilentlyContinue
          }

          # 2) Crear tarea one-shot interactiva con wrapper .cmd
          $start = (Get-Date).AddSeconds(20).ToString('HH:mm')
          $argsCreate = @('/Create','/TN',"$tn",
                          '/SC','ONCE','/ST',"$start",
                          '/TR',"`"$cmd`"",
                          '/RL','HIGHEST','/F','/RU',"$u","/IT")
          $pCreate = Start-Process -FilePath schtasks -ArgumentList $argsCreate -NoNewWindow -Wait -PassThru
          if ($pCreate.ExitCode -ne 0) {
            throw "schtasks /Create falló con ExitCode=$($pCreate.ExitCode). Asegurate de que '$u' está logueado (autologon)."
          }

          # 3) Ejecutar ya (por si el reloj se pisa)
          $pRun = Start-Process -FilePath schtasks -ArgumentList @('/Run','/TN',"$tn") -NoNewWindow -Wait -PassThru -ErrorAction SilentlyContinue

          # 4) Info (no romper si falla)
          $null = Start-Process -FilePath schtasks -ArgumentList @('/Query','/TN',"$tn",'/V','/FO','LIST') -NoNewWindow -Wait -PassThru -ErrorAction SilentlyContinue


      - name: (Opcional) Tail del log
        if: ${{ inputs.tail_log }}
        run: |
          $logFile = $env:LOG_FILE
          for ($i=0; $i -lt 300; $i++) {
            if (Test-Path $logFile) { break }
            Start-Sleep 1
          }
          if (Test-Path $logFile) {
            Write-Host "=== Últimas 200 líneas de $logFile ==="
            Get-Content -LiteralPath $logFile -Tail 200
          } else {
            Write-Host "No se encontró el log aún: $logFile"
          }
