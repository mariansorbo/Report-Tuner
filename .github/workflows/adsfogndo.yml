name: Launch GUI Script V4 (Interactive)

on:
  workflow_dispatch:

env:
  TASK_NAME: "LanzarAppGUI"
  SCRIPT_TO_RUN: "C:\\Users\\Mariano\\Documents\\DMV Automation - 10 Jun V2\\One_new-Copy2 (2).py"
  LOG_DIR: "C:\\Scripts\\logs"

jobs:
  launch:
    runs-on: [self-hosted, windows, gui]
    defaults:
      run:
        shell: powershell

    steps:
      - name: Echo contexto (usuario/sesión/runner)
        run: |
          whoami
          $env:USERNAME
          qwinsta
          Get-Process -Name "Runner.Worker" -ErrorAction SilentlyContinue | Select-Object Id,Name,SessionId,StartTime | Format-Table -AutoSize

      - name: Preparar rutas (python, script, log)
        id: prep
        run: |
          $py = (Get-Command python.exe -ErrorAction Stop).Source
          if (-not (Test-Path $py)) { throw "No se encontró python.exe" }

          $script = "${{ env.SCRIPT_TO_RUN }}"
          if (-not (Test-Path $script)) { throw "No existe el script: $script" }

          $dir = Split-Path -Path $script -Parent
          if (-not (Test-Path "${{ env.LOG_DIR }}")) { New-Item -ItemType Directory -Force -Path "${{ env.LOG_DIR }}" | Out-Null }
          $ts  = Get-Date -Format 'yyyyMMdd_HHmmss'
          $log = Join-Path "${{ env.LOG_DIR }}" ("LanzarAppGUI_{0}.log" -f $ts)

          # Comando final que ejecutará la tarea:
          # cd /d "<dir>" & "<python>" -u "<script>" > "<log>" 2>&1
          $cmdInner = 'cd /d "{0}" & "{1}" -u "{2}" > "{3}" 2>&1' -f $dir, $py, $script, $log

          # Guardar en salidas para siguientes pasos
          "PY=$py"      | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "DIR=$dir"    | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "LOG=$log"    | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "CMD=$cmdInner" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

          Write-Host "python.exe: $py"
          Write-Host "script: $script"
          Write-Host "dir: $dir"
          Write-Host "log: $log"
          Write-Host "cmdInner: $cmdInner"

      - name: (Re)crear tarea con token interactivo (/IT) y RunLevel Highest
        run: |
          $tn  = "${{ env.TASK_NAME }}"
          $cmd = "${{ steps.prep.outputs.CMD }}"

          # Programar a futuro lejano (placeholder), /RL HIGHEST y /IT para usar el token interactivo
          # Nota: usamos cmd.exe /c "<cmdInner>"
          $start = (Get-Date).AddYears(10).ToString("HH:mm")   # hora dummy
          schtasks /Delete /TN "$tn" /F 2>$null | Out-Null

          $ok = schtasks /Create `
            /SC ONCE /ST $start /SD 01/01/2099 `
            /TN "$tn" `
            /TR "cmd.exe /c $cmd" `
            /RL HIGHEST `
            /IT `
            /F

          if ($LASTEXITCODE -ne 0) { throw "schtasks /Create falló con código $LASTEXITCODE" }

          schtasks /Query /TN "$tn" /XML > "$env:RUNNER_TEMP\${tn}.xml"
          Write-Host "XML de la tarea guardado en $env:RUNNER_TEMP\${tn}.xml"

      - name: Disparar tarea ahora y esperar log
        run: |
          $tn  = "${{ env.TASK_NAME }}"
          $log = "${{ steps.prep.outputs.LOG }}"

          schtasks /Run /TN "$tn"
          if ($LASTEXITCODE -ne 0) { throw "schtasks /Run falló con código $LASTEXITCODE" }

          Write-Host "Esperando la creación del log: $log"
          $deadline = (Get-Date).AddMinutes(3)
          while ((Get-Date) -lt $deadline) {
            if (Test-Path $log) { break }
            Start-Sleep -Seconds 2
          }

          if (-not (Test-Path $log)) {
            Write-Host "⚠️  No apareció el log aún. Mostrando estado de la tarea…"
            schtasks /Query /TN "$tn" /V /FO LIST
          } else {
            Write-Host "---- Tail del log ----"
            Start-Sleep -Seconds 2
            Get-Content $log -Tail 200
          }

      - name: Subir artefactos (log + XML)
        uses: actions/upload-artifact@v4
        with:
          name: LanzarAppGUI-artifacts
          path: |
            ${{ steps.prep.outputs.LOG }}
            ${{ runner.temp }}\${{ env.TASK_NAME }}.xml
          if-no-files-found: warn

      - name: Eventos recientes del Programador de tareas (diagnóstico)
        run: |
          $since = (Get-Date).AddMinutes(-15)
          Get-WinEvent -LogName Microsoft-Windows-TaskScheduler/Operational `
            | Where-Object { $_.TimeCreated -ge $since } `
            | Select-Object TimeCreated, Id, LevelDisplayName, Message `
            | Sort-Object TimeCreated `
            | Format-Table -AutoSize
