name: Launch GUI Script V2 (hardened)

on:
  workflow_dispatch:
    inputs:
      wait_for_login:
        description: "Esperar sesión interactiva de 'mariano'"
        type: boolean
        default: true
      force_display:
        description: "Forzar resolución con NirCmd antes de ejecutar"
        type: boolean
        default: true
      tail_log:
        description: "Hacer tail del log al final"
        type: boolean
        default: true

env:
  # ⬇️ Ajustá solo esta ruta si cambiás el script
  SCRIPT_TO_RUN: "C:\\Users\\mariano\\Documents\\DMV Automation - 10 Jun V2\\One_new-Copy2 (2).py"
  TASK_NAME: "LanzarAppGUI"
  LOG_DIR: "C:\\Scripts\\logs"
  RUN_AS_USER: ".\\mariano"
  NIRCMD_EXE: "C:\\nircmd.exe"
  RES_W: "1920"
  RES_H: "1080"
  RES_BPP: "32"

jobs:
  launch:
    # El runner debe ser el self-hosted dentro de la VM Windows (con GUI)
    runs-on: [self-hosted, windows, gui]
    defaults:
      run:
        shell: powershell

    steps:
      - name: (Opcional) Esperar sesión interactiva de $env:RUN_AS_USER
        if: ${{ inputs.wait_for_login }}
        run: |
          $userShort = ($env:RUN_AS_USER -split '\\')[-1]
          for ($i=0; $i -lt 180; $i++) {
            $q = (quser | Out-String)
            if ($q -match "^\s*$([regex]::Escape($userShort))\s+.*\s+Active") {
              Write-Host "OK: Sesión de $userShort activa"
              exit 0
            }
            Start-Sleep 2
          }
          throw "Timeout esperando sesión interactiva de $userShort"

      - name: (Opcional) Forzar resolución con NirCmd (idempotente)
        if: ${{ inputs.force_display }}
        run: |
          if (-not (Test-Path "${env:NIRCMD_EXE}")) { throw "No existe ${env:NIRCMD_EXE}" }
          & "${env:NIRCMD_EXE}" setdisplay ${env:RES_W} ${env:RES_H} ${env:RES_BPP} 2>$null
          Write-Host "Resolución forzada a ${env:RES_W}x${env:RES_H}x${env:RES_BPP}"

      - name: Preparar y registrar tarea programada (usuario interactivo)
        run: |
          # Resolver Python (python.exe o py.exe)
          $python = (Get-Command python.exe -ErrorAction SilentlyContinue).Source
          $usePyLauncher = $false
          if (-not $python) {
            $pyLauncher = (Get-Command py.exe -ErrorAction SilentlyContinue).Source
            if (-not $pyLauncher) { throw "No se encontró Python (python.exe/py.exe) en PATH" }
            $python = $pyLauncher
            $usePyLauncher = $true
          }

          $script = "${env:SCRIPT_TO_RUN}"
          if (-not (Test-Path $script)) { throw "No existe el script: $script" }

          # Logs
          New-Item -ItemType Directory -Force -Path "${env:LOG_DIR}" | Out-Null
          $ts = Get-Date -Format 'yyyyMMdd_HHmmss'
          $logFile = Join-Path "${env:LOG_DIR}" ("script_" + $ts + ".log")

          # Comando con cwd del script + redirección a log
          $workDir = Split-Path $script
          if ($usePyLauncher) {
            $cmdCore = 'py.exe -3 "{0}"' -f $script
          } else {
            $cmdCore = '"{0}" "{1}"' -f $python, $script
          }
          $cmdLine = 'cd /d "{0}" && {1} > "{2}" 2>&1' -f $workDir, $cmdCore, $logFile

          # Acción y disparador "one-shot"
          $action    = New-ScheduledTaskAction -Execute "cmd.exe" -Argument ('/c ' + $cmdLine)
          $trigger   = New-ScheduledTaskTrigger -Once -At ((Get-Date).AddSeconds(7))

          # MUY IMPORTANTE: usuario interactivo + highest
          $principal = New-ScheduledTaskPrincipal -UserId "${env:RUN_AS_USER}" -LogonType Interactive -RunLevel Highest
          $settings  = New-ScheduledTaskSettingsSet -Compatibility Win8 -AllowStartOnDemand

          # Re-registrar para garantizar principal/acción correctos
          if (Get-ScheduledTask -TaskName "${env:TASK_NAME}" -ErrorAction SilentlyContinue) {
            Unregister-ScheduledTask -TaskName "${env:TASK_NAME}" -Confirm:$false
          }
          $task = New-ScheduledTask -Action $action -Trigger $trigger -Principal $principal -Settings $settings
          Register-ScheduledTask -TaskName "${env:TASK_NAME}" -InputObject $task | Out-Null

          # Exportar la ruta del log para el tail
          "`nLOG_FILE=$logFile" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          Write-Host "Log: $logFile"

      - name: Lanzar tarea (en sesión interactiva)
        run: |
          Start-ScheduledTask -TaskName "${env:TASK_NAME}"
          Write-Host "Lanzado ${env:SCRIPT_TO_RUN}"

      - name: (Opcional) Tail del log
        if: ${{ inputs.tail_log }}
        run: |
          $logFile = $env:LOG_FILE
          # Esperar a que aparezca el log (hasta 180s)
          for ($i=0; $i -lt 180; $i++) {
            if (Test-Path $logFile) { break }
            Start-Sleep 1
          }
          if (Test-Path $logFile) {
            Write-Host "=== Últimas 200 líneas de $logFile ==="
            Get-Content -LiteralPath $logFile -Tail 200
          } else {
            Write-Host "No se encontró el log aún: $logFile"
          }
