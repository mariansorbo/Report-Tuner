name: Launch GUI Script V2 (hybrid-robust)

on:
  workflow_dispatch:
    inputs:
      wait_for_login:
        description: "Verificar/esperar sesión interactiva de 'mariano' (autologon)"
        type: boolean
        default: true
      force_display:
        description: "Forzar resolución con NirCmd antes de ejecutar"
        type: boolean
        default: true
      tail_log:
        description: "Mostrar tail del log al final"
        type: boolean
        default: true

env:
  # === Ajustá solo esto si cambia tu script ===
  SCRIPT_TO_RUN: "C:\\Users\\mariano\\Documents\\DMV Automation - 10 Jun V2\\One_new-Copy2 (2).py"

  RUN_AS_USER: ".\\mariano"       # principal interactivo
  RUN_AS_SHORT: "mariano"         # para matchear quser
  NIRCMD_EXE: "C:\\nircmd.exe"
  RES_W: "1920"
  RES_H: "1080"
  RES_BPP: "32"

  TASK_NAME: "LanzarAppGUI"
  LOG_DIR: "C:\\Scripts\\logs"
  TASK_WRAPPER_DIR: "C:\\Scripts\\tasks"

jobs:
  launch:
    runs-on: [self-hosted, windows, gui]
    defaults:
      run:
        shell: powershell

    steps:
      - name: (Opcional) Esperar sesión interactiva de $env:RUN_AS_SHORT
        if: ${{ inputs.wait_for_login }}
        run: |
          $u = "${env:RUN_AS_SHORT}"
          $deadline = (Get-Date).AddMinutes(5)
          do {
            $q = (quser | Out-String)
            if ($q -match "(?im)^[\s>]*$([regex]::Escape($u))\b.*\sActive\b") { 
              Write-Host "OK: sesión de $u activa"; exit 0 
            }
            Start-Sleep 2
          } while ((Get-Date) -lt $deadline)
          Write-Host "=== quser ===`n$q"
          throw "No hay sesión interactiva de '$u'. Corré el workflow 1 (autologon + display) y reintentá."

      - name: (Opcional) Forzar resolución con NirCmd (idempotente)
        if: ${{ inputs.force_display }}
        run: |
          if (-not (Test-Path "${env:NIRCMD_EXE}")) { throw "No existe ${env:NIRCMD_EXE}" }
          & "${env:NIRCMD_EXE}" setdisplay ${env:RES_W} ${env:RES_H} ${env:RES_BPP} 2>$null
          Write-Host "Resolución forzada a ${env:RES_W}x${env:RES_H}x${env:RES_BPP}"

      - name: Preparar rutas, permisos y wrapper .cmd
        id: prep
        run: |
          $ErrorActionPreference = 'Stop'

          # Dirs
          New-Item -ItemType Directory -Force -Path "${env:LOG_DIR}" | Out-Null
          New-Item -ItemType Directory -Force -Path "${env:TASK_WRAPPER_DIR}" | Out-Null

          # Asegurar que mariano puede escribir logs (evita cuelgue por log ausente)
          icacls "${env:LOG_DIR}" /grant "${env:RUN_AS_SHORT}:(OI)(CI)M" /T | Out-Null

          # Resolver Python (prioridad py.exe, luego python.exe)
          $pyCmd = $null
          $pyLauncher = (Get-Command py.exe -ErrorAction SilentlyContinue).Source
          if ($pyLauncher) {
            $pyCmd = '"py.exe" -3'
          } else {
            $pyExe = (Get-Command python.exe -ErrorAction SilentlyContinue).Source
            if (-not $pyExe) { throw "No se encontró Python (py.exe ni python.exe) en PATH" }
            $pyCmd = '"' + $pyExe + '"'
          }

          # Validar script
          $script = "${env:SCRIPT_TO_RUN}"
          if (-not (Test-Path $script)) { throw "No existe el script: $script" }

          # Paths únicos
          $ts       = Get-Date -Format 'yyyyMMdd_HHmmss'
          $logFile  = Join-Path "${env:LOG_DIR}" ("script_" + $ts + ".log")
          $cmdFile  = Join-Path "${env:TASK_WRAPPER_DIR}" ("run_" + $ts + ".cmd")
          $workDir  = Split-Path $script

          # Wrapper .cmd (siempre comillas y línea START para garantizar log)
          $cmdLines = @(
            '@echo off'
            'setlocal'
            'chcp 65001 >nul'
            ('if not exist "{0}" mkdir "{0}"' -f "${env:LOG_DIR}")
            ('echo [%%DATE%% %%TIME%%] START > "{0}"' -f $logFile)
            ('cd /d "{0}"' -f $workDir)
            ('{0} "{1}" >> "{2}" 2>&1' -f $pyCmd, $script, $logFile)
          )
          Set-Content -LiteralPath $cmdFile -Value $cmdLines -Encoding ASCII

          "LOG_FILE=$logFile" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "CMD_FILE=$cmdFile" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

          Write-Host "Wrapper: $cmdFile"
          Write-Host "Log:     $logFile"

      - name: Registrar/Actualizar tarea '$env:TASK_NAME' (usuario interactivo)
        run: |
          $ErrorActionPreference = 'Stop'
          $taskName = "${env:TASK_NAME}"
          $user     = "${env:RUN_AS_USER}"
          $cmdFile  = "${env:CMD_FILE}"

          $action    = New-ScheduledTaskAction -Execute "cmd.exe" -Argument ('/c "' + $cmdFile + '"')
          $trigger   = New-ScheduledTaskTrigger -Once -At ((Get-Date).AddSeconds(15))
          $principal = New-ScheduledTaskPrincipal -UserId $user -LogonType Interactive -RunLevel Highest
          $settings  = New-ScheduledTaskSettingsSet -Compatibility Win8 -AllowStartOnDemand

          $exists = Get-ScheduledTask -TaskName $taskName -ErrorAction SilentlyContinue
          if ($exists) {
            # Set-ScheduledTask no cambia Principal -> re-registramos limpio
            Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue
          }
          $task = New-ScheduledTask -Action $action -Trigger $trigger -Principal $principal -Settings $settings
          Register-ScheduledTask -TaskName $taskName -InputObject $task | Out-Null

          # Lanzar ahora
          Start-ScheduledTask -TaskName $taskName

      - name: Estado de tarea (poll corto) + Tail del log (con timeout)
        if: ${{ inputs.tail_log }}
        run: |
          $ErrorActionPreference = 'Continue'
          $taskName = "${env:TASK_NAME}"
          $logFile  = "${env:LOG_FILE}"

          Write-Host ">>> Poll de estado (hasta 120s)"
          for ($i=0; $i -lt 24; $i++) {
            $info = schtasks /Query /TN "$taskName" /V /FO LIST 2>$null
            ($info -split "`r?`n") | Where-Object { $_ -match 'Last Run Time|Last Run Result|Next Run Time|Task To Run|Run As User|Status' } | ForEach-Object { Write-Host $_ }
            Start-Sleep 5
          }

          Write-Host "`n>>> Esperar log (hasta 240s)"
          for ($i=0; $i -lt 240; $i++) {
            if (Test-Path $logFile) { break }
            Start-Sleep 1
          }

          if (Test-Path $logFile) {
            Write-Host "=== Últimas 200 líneas de $logFile ==="
            Get-Content -LiteralPath $logFile -Tail 200
          } else {
            Write-Host "ATENCIÓN: el log no apareció: $logFile"
            Write-Host "Suele ser permisos en ${env:LOG_DIR} o que el wrapper no se ejecutó."
            Write-Host "Chequeos rápidos:"
            Write-Host "  - Test-Path '${env:CMD_FILE}'"
            Write-Host "  - Abrí la tarea '$taskName' en el Programador de tareas y mirá 'Historial' y 'Último resultado' (0x0=OK)."
          }
